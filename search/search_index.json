{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"formats/","text":"Formats File and data formats used by Tanki Online and the Alternativa3D engine. Tanki Online A3D BattleMap LightmapData Tara Alternativa3D A3D","title":"Formats"},{"location":"formats/#formats","text":"File and data formats used by Tanki Online and the Alternativa3D engine.","title":"Formats"},{"location":"formats/#tanki-online","text":"A3D BattleMap LightmapData Tara","title":"Tanki Online"},{"location":"formats/#alternativa3d","text":"A3D","title":"Alternativa3D"},{"location":"formats/alternativa3d/a3d/","text":"A3D (Alternativa3D) There are currently 2 major versions of the A3D format: A3D1 and A3D2 which are supported by the latest flash release of the Alternativa3D engine (8.32.0), this format is not related to the modern A3D format used in Tanki Online. A3D1 Oldest version of the format, uses the alternativa protocol serialisation format. Research materials Alternativa3D engine parser Format struct A3D1 { short version; // 1 short unused; // 0 OptionalMask optionalMask; A3D1Box boxes[]; // Optional A3D1Geometry geometry[]; // Optional A3D1Image images[]; // Optional A3D1Map maps[]; // Optional A3D1Material materials[]; // Optional A3D1Object objects[]; // Optional }; A3D1Box struct A3D1Box { float bounds[]; // Optional int id; // Optional }; A3D1Geometry struct A3D1Geometry { int id; // Optional A3D1IndexBuffer indexBuffer; // Optional A3D1VertexBuffer vertexBuffers[]; // Optional }; A3D1Image struct A3D1Image { int id; // Optional char url[]; // Optional }; A3D1Map struct A3D1Map { short channel; // Required int id; // Optional int imageID; // Optional float uOffset; // Optional float uScale; // Optional float vOffset; // Optional float vScale; // Optional }; A3D1Material struct A3D1Material { int diffuseMapID; // Optional int glossinessMapID; // Optional int id; // Optional int lightMapID; // Optional int normalMapID; // Optional int opacityMapID; // Optional int specularMapID; // Optional }; A3D1Object struct A3D1Object { int boundBoxID; // Optional int geometryID; // Optional int id; // Optional char name[]; // Optional int parentID; // Optional A3D1Surface surfaces[]; // Optional A3D1Transform transform; // Optional bool visible; // Optional }; A3D1Transform struct A3D1Transform { A3DMatrix matrix; // Optional }; A3D1IndexBuffer struct A3D1IndexBuffer { char byteBuffer[]; // Optional int indexCount; // Required }; A3D1VertexBuffer struct A3D1VertexBuffer { char attributes[]; // Optional char byteBuffer[]; // Optional short vertexCount; // Required }; attributes The attributes field specifies the format of each vertex inside the byteBuffer , there can be any amount of attributes in any order. It is read as 1 byte integers which each correspond to one of the vertex types: 0 - position 1 - normal 2 - tangent 3 - joint 4 - UV1 5 - UV2 A3D1Surface struct A3D1Surface { int indexBegin; // Required int materialID; // Optional int numTriangles; // Required }; A3D2 Newest version supported by the opensource flash Alternativa3D engine, also uses the alternativa protocol serialisation format (like A3D1). This version of the format adds zlib compression support, light objects, animation, skinning, sprites and decals as well as reducing amount of optional flags per model by properly using optional fields (only marking select fields as optional instead of most of them). There are 4 minor versions of this format: | Version | Notes | |---------|-----------------------------------------| | 2.0 | | | 2.4 | aka A3DExtra1, adds A3D2Layer | | 2.5 | aka A3DExtra2, adds A3D2Camera, A3D2LOD | | 2.6 | Package compression is mandatory | Research materials Alternativa3D engine parser Official design document Format struct A3D2 { A3D2Package package; }; A3D2Package The A3D2 is wrapped in a compressable block called the package, it is placed at the very start of the file and begins with a length field, this is followed by a stream of bytes (size of the length field) which contains the A3D2 data (could be zlib compressed, this is encoded in the length field). Short package 0G000000 00000000 G Description 0 Package data is not compressed 1 Package data is compressed Length of the package is contained in the last 6 bits of the first byte + the next byte, resulting in a maximum length of 16,384 bytes. Long package 10000000 00000000 00000000 00000000 Length of the package is contained in the last 7 bits of the first byte + the next 3 bytes, resulting in a maximum length of 2147483648 bytes. Compression is assumed to be true. Data The uncompressed package data stores the actual file data: struct A3D2Package { OptionalMask optionalMask; A3D2AmbientLight ambientLights[]; // Optional A3D2AnimationClip animationClips[]; // Optional A3D2AnimationTrack animationTracks[]; // Optional A3D2Box boxes[]; // Optional A3D2CubeMap cubeMaps[]; // Optional A3D2Decal decals[]; // Optional A3D2DirectionalLight directionalLights[]; // Optional A3D2Image images[]; // Optional A3D2IndexBuffer indexBuffers[]; // Optional A3D2Joint joints[]; // Optional A3D2Map maps[]; // Optional A3D2Material materials[]; // Optional A3D2Mesh meshes[]; // Optional A3D2Object objects[]; // Optional A3D2OmniLight omniLights[]; // Optional A3D2SpotLight spotLights[]; // Optional A3D2Sprite sprites[]; // Optional A3D2Skin skins[]; // Optional A3D2VertexBuffer vertexBuffers[]; // Optional A3D2Layer layers[]; // Optional, 2.4 only A3D2Camera cameras[]; // Optional, 2.5 only A3D2LOD LODs[]; // Optional, 2.5 only }; A3D2AmbientLight A3D2AnimationClip A3D2AnimationTrack A3D2Box A3D2CubeMap A3D2Decal A3D2DirectionalLight A3D2Image A3D2IndexBuffer A3D2Joint A3D2Map A3D2Material A3D2Mesh A3D2Object A3D2OmniLight A3D2SpotLight A3D2Sprite A3D2Skin A3D2VertexBuffer A3D2Layer A3D2Camera A3D2LOD","title":"A3D (Alternativa3D)"},{"location":"formats/alternativa3d/a3d/#a3d-alternativa3d","text":"There are currently 2 major versions of the A3D format: A3D1 and A3D2 which are supported by the latest flash release of the Alternativa3D engine (8.32.0), this format is not related to the modern A3D format used in Tanki Online.","title":"A3D (Alternativa3D)"},{"location":"formats/alternativa3d/a3d/#a3d1","text":"Oldest version of the format, uses the alternativa protocol serialisation format.","title":"A3D1"},{"location":"formats/alternativa3d/a3d/#research-materials","text":"Alternativa3D engine parser","title":"Research materials"},{"location":"formats/alternativa3d/a3d/#format","text":"struct A3D1 { short version; // 1 short unused; // 0 OptionalMask optionalMask; A3D1Box boxes[]; // Optional A3D1Geometry geometry[]; // Optional A3D1Image images[]; // Optional A3D1Map maps[]; // Optional A3D1Material materials[]; // Optional A3D1Object objects[]; // Optional };","title":"Format"},{"location":"formats/alternativa3d/a3d/#a3d1box","text":"struct A3D1Box { float bounds[]; // Optional int id; // Optional };","title":"A3D1Box"},{"location":"formats/alternativa3d/a3d/#a3d1geometry","text":"struct A3D1Geometry { int id; // Optional A3D1IndexBuffer indexBuffer; // Optional A3D1VertexBuffer vertexBuffers[]; // Optional };","title":"A3D1Geometry"},{"location":"formats/alternativa3d/a3d/#a3d1image","text":"struct A3D1Image { int id; // Optional char url[]; // Optional };","title":"A3D1Image"},{"location":"formats/alternativa3d/a3d/#a3d1map","text":"struct A3D1Map { short channel; // Required int id; // Optional int imageID; // Optional float uOffset; // Optional float uScale; // Optional float vOffset; // Optional float vScale; // Optional };","title":"A3D1Map"},{"location":"formats/alternativa3d/a3d/#a3d1material","text":"struct A3D1Material { int diffuseMapID; // Optional int glossinessMapID; // Optional int id; // Optional int lightMapID; // Optional int normalMapID; // Optional int opacityMapID; // Optional int specularMapID; // Optional };","title":"A3D1Material"},{"location":"formats/alternativa3d/a3d/#a3d1object","text":"struct A3D1Object { int boundBoxID; // Optional int geometryID; // Optional int id; // Optional char name[]; // Optional int parentID; // Optional A3D1Surface surfaces[]; // Optional A3D1Transform transform; // Optional bool visible; // Optional };","title":"A3D1Object"},{"location":"formats/alternativa3d/a3d/#a3d1transform","text":"struct A3D1Transform { A3DMatrix matrix; // Optional };","title":"A3D1Transform"},{"location":"formats/alternativa3d/a3d/#a3d1indexbuffer","text":"struct A3D1IndexBuffer { char byteBuffer[]; // Optional int indexCount; // Required };","title":"A3D1IndexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d1vertexbuffer","text":"struct A3D1VertexBuffer { char attributes[]; // Optional char byteBuffer[]; // Optional short vertexCount; // Required };","title":"A3D1VertexBuffer"},{"location":"formats/alternativa3d/a3d/#attributes","text":"The attributes field specifies the format of each vertex inside the byteBuffer , there can be any amount of attributes in any order. It is read as 1 byte integers which each correspond to one of the vertex types: 0 - position 1 - normal 2 - tangent 3 - joint 4 - UV1 5 - UV2","title":"attributes"},{"location":"formats/alternativa3d/a3d/#a3d1surface","text":"struct A3D1Surface { int indexBegin; // Required int materialID; // Optional int numTriangles; // Required };","title":"A3D1Surface"},{"location":"formats/alternativa3d/a3d/#a3d2","text":"Newest version supported by the opensource flash Alternativa3D engine, also uses the alternativa protocol serialisation format (like A3D1). This version of the format adds zlib compression support, light objects, animation, skinning, sprites and decals as well as reducing amount of optional flags per model by properly using optional fields (only marking select fields as optional instead of most of them). There are 4 minor versions of this format: | Version | Notes | |---------|-----------------------------------------| | 2.0 | | | 2.4 | aka A3DExtra1, adds A3D2Layer | | 2.5 | aka A3DExtra2, adds A3D2Camera, A3D2LOD | | 2.6 | Package compression is mandatory |","title":"A3D2"},{"location":"formats/alternativa3d/a3d/#research-materials_1","text":"Alternativa3D engine parser Official design document","title":"Research materials"},{"location":"formats/alternativa3d/a3d/#format_1","text":"struct A3D2 { A3D2Package package; };","title":"Format"},{"location":"formats/alternativa3d/a3d/#a3d2package","text":"The A3D2 is wrapped in a compressable block called the package, it is placed at the very start of the file and begins with a length field, this is followed by a stream of bytes (size of the length field) which contains the A3D2 data (could be zlib compressed, this is encoded in the length field).","title":"A3D2Package"},{"location":"formats/alternativa3d/a3d/#short-package","text":"0G000000 00000000 G Description 0 Package data is not compressed 1 Package data is compressed Length of the package is contained in the last 6 bits of the first byte + the next byte, resulting in a maximum length of 16,384 bytes.","title":"Short package"},{"location":"formats/alternativa3d/a3d/#long-package","text":"10000000 00000000 00000000 00000000 Length of the package is contained in the last 7 bits of the first byte + the next 3 bytes, resulting in a maximum length of 2147483648 bytes. Compression is assumed to be true.","title":"Long package"},{"location":"formats/alternativa3d/a3d/#data","text":"The uncompressed package data stores the actual file data: struct A3D2Package { OptionalMask optionalMask; A3D2AmbientLight ambientLights[]; // Optional A3D2AnimationClip animationClips[]; // Optional A3D2AnimationTrack animationTracks[]; // Optional A3D2Box boxes[]; // Optional A3D2CubeMap cubeMaps[]; // Optional A3D2Decal decals[]; // Optional A3D2DirectionalLight directionalLights[]; // Optional A3D2Image images[]; // Optional A3D2IndexBuffer indexBuffers[]; // Optional A3D2Joint joints[]; // Optional A3D2Map maps[]; // Optional A3D2Material materials[]; // Optional A3D2Mesh meshes[]; // Optional A3D2Object objects[]; // Optional A3D2OmniLight omniLights[]; // Optional A3D2SpotLight spotLights[]; // Optional A3D2Sprite sprites[]; // Optional A3D2Skin skins[]; // Optional A3D2VertexBuffer vertexBuffers[]; // Optional A3D2Layer layers[]; // Optional, 2.4 only A3D2Camera cameras[]; // Optional, 2.5 only A3D2LOD LODs[]; // Optional, 2.5 only };","title":"Data"},{"location":"formats/alternativa3d/a3d/#a3d2ambientlight","text":"","title":"A3D2AmbientLight"},{"location":"formats/alternativa3d/a3d/#a3d2animationclip","text":"","title":"A3D2AnimationClip"},{"location":"formats/alternativa3d/a3d/#a3d2animationtrack","text":"","title":"A3D2AnimationTrack"},{"location":"formats/alternativa3d/a3d/#a3d2box","text":"","title":"A3D2Box"},{"location":"formats/alternativa3d/a3d/#a3d2cubemap","text":"","title":"A3D2CubeMap"},{"location":"formats/alternativa3d/a3d/#a3d2decal","text":"","title":"A3D2Decal"},{"location":"formats/alternativa3d/a3d/#a3d2directionallight","text":"","title":"A3D2DirectionalLight"},{"location":"formats/alternativa3d/a3d/#a3d2image","text":"","title":"A3D2Image"},{"location":"formats/alternativa3d/a3d/#a3d2indexbuffer","text":"","title":"A3D2IndexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d2joint","text":"","title":"A3D2Joint"},{"location":"formats/alternativa3d/a3d/#a3d2map","text":"","title":"A3D2Map"},{"location":"formats/alternativa3d/a3d/#a3d2material","text":"","title":"A3D2Material"},{"location":"formats/alternativa3d/a3d/#a3d2mesh","text":"","title":"A3D2Mesh"},{"location":"formats/alternativa3d/a3d/#a3d2object","text":"","title":"A3D2Object"},{"location":"formats/alternativa3d/a3d/#a3d2omnilight","text":"","title":"A3D2OmniLight"},{"location":"formats/alternativa3d/a3d/#a3d2spotlight","text":"","title":"A3D2SpotLight"},{"location":"formats/alternativa3d/a3d/#a3d2sprite","text":"","title":"A3D2Sprite"},{"location":"formats/alternativa3d/a3d/#a3d2skin","text":"","title":"A3D2Skin"},{"location":"formats/alternativa3d/a3d/#a3d2vertexbuffer","text":"","title":"A3D2VertexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d2layer","text":"","title":"A3D2Layer"},{"location":"formats/alternativa3d/a3d/#a3d2camera","text":"","title":"A3D2Camera"},{"location":"formats/alternativa3d/a3d/#a3d2lod","text":"","title":"A3D2LOD"},{"location":"formats/tanki/a3d/","text":"A3D (Tanki Online) Custom 3D model format used by Tanki Online HTML5 for HD maps and all tank models (including legacy) to replace the old 3ds format (non HD maps still use 3ds). There are three versions of the A3D file format which are used for different types of objects in the game: version 1 files are no longer used, version 2 files are used for map geometry (props and terrain meshes etc...), version 3 files are used for tank models (turrets and hulls). The format is able to store: basic material data, mesh data (including coordinate, UV, normals and colour vertex buffers), submesh/surface data (with material indices), transform data and hierarchy data. Format Padding Padding is only used by version 3 models, it is calculated using: paddingSize = (((dataLength + 3) // 4) * 4) - dataLength Strings Version 2 uses null terminated strings, e.g. the strings have no length and characters are read from the stream until a null is reached ( \\0 ). Version 3 uses an int32 length field which comes before the characters with no null terminator, this is followed by padding bytes (padding calculated from string length). Data blocks The A3D file format is based around data blocks, data blocks are sections of the file which encode different data in the model such as meshes and materials. struct DataBlock { int dataBlockSignature; // Identifies which datablock this is int dataBlockLength; // This field is used to compute padding in version 3 files, other versions don't use it // Data block specifc data goes here }; Version 1 TODO Version 2 struct { char signature[4]; // \"A3D\\0\" int version; // 2 RootDataBlock root; }; Root block This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; }; Material block struct MaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; }; Mesh block struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int faceCount; short indices[faceCount*3]; // array of 16 bit indices int smoothingGroups[faceCount]; short materialID; } submeshes[submeshCount]; } mesh[meshCount]; }; Transform block struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks }; Object block struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { string name; int meshID; int transformID; } objects[objectCount]; }; Version 3 struct { char signature[4]; // \"A3D\\0\" int version; // 3 RootDataBlock root; }; Root block This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; }; Material block struct A3DMaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; byte padding[]; // depends on materialBlockLength }; Mesh block struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { string name; float bboxMaxX; float bboxMaxY; float bboxMaxZ; float bboxMinX; float bboxMinY; float bboxMinZ; float unknown; int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int indexCount; short indices[indexCount]; // array of 16 bit indices byte padding[]; // dependent on indexCount*2 } submeshes[submeshCount]; } mesh[meshCount]; byte padding[]; // depends on meshBlockLength }; Transform block struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { string name; float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks byte padding[]; // depends on transformBlockLength }; Object block struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { int meshID; int transformID; int materialCount; int materialIDs[materialCount]; } objects[objectCount]; byte padding[]; // depends on objectBlockLength };","title":"A3D (Tanki Online)"},{"location":"formats/tanki/a3d/#a3d-tanki-online","text":"Custom 3D model format used by Tanki Online HTML5 for HD maps and all tank models (including legacy) to replace the old 3ds format (non HD maps still use 3ds). There are three versions of the A3D file format which are used for different types of objects in the game: version 1 files are no longer used, version 2 files are used for map geometry (props and terrain meshes etc...), version 3 files are used for tank models (turrets and hulls). The format is able to store: basic material data, mesh data (including coordinate, UV, normals and colour vertex buffers), submesh/surface data (with material indices), transform data and hierarchy data.","title":"A3D (Tanki Online)"},{"location":"formats/tanki/a3d/#format","text":"","title":"Format"},{"location":"formats/tanki/a3d/#padding","text":"Padding is only used by version 3 models, it is calculated using: paddingSize = (((dataLength + 3) // 4) * 4) - dataLength","title":"Padding"},{"location":"formats/tanki/a3d/#strings","text":"Version 2 uses null terminated strings, e.g. the strings have no length and characters are read from the stream until a null is reached ( \\0 ). Version 3 uses an int32 length field which comes before the characters with no null terminator, this is followed by padding bytes (padding calculated from string length).","title":"Strings"},{"location":"formats/tanki/a3d/#data-blocks","text":"The A3D file format is based around data blocks, data blocks are sections of the file which encode different data in the model such as meshes and materials. struct DataBlock { int dataBlockSignature; // Identifies which datablock this is int dataBlockLength; // This field is used to compute padding in version 3 files, other versions don't use it // Data block specifc data goes here };","title":"Data blocks"},{"location":"formats/tanki/a3d/#version-1","text":"TODO","title":"Version 1"},{"location":"formats/tanki/a3d/#version-2","text":"struct { char signature[4]; // \"A3D\\0\" int version; // 2 RootDataBlock root; };","title":"Version 2"},{"location":"formats/tanki/a3d/#root-block","text":"This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; };","title":"Root block"},{"location":"formats/tanki/a3d/#material-block","text":"struct MaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; };","title":"Material block"},{"location":"formats/tanki/a3d/#mesh-block","text":"struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int faceCount; short indices[faceCount*3]; // array of 16 bit indices int smoothingGroups[faceCount]; short materialID; } submeshes[submeshCount]; } mesh[meshCount]; };","title":"Mesh block"},{"location":"formats/tanki/a3d/#transform-block","text":"struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks };","title":"Transform block"},{"location":"formats/tanki/a3d/#object-block","text":"struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { string name; int meshID; int transformID; } objects[objectCount]; };","title":"Object block"},{"location":"formats/tanki/a3d/#version-3","text":"struct { char signature[4]; // \"A3D\\0\" int version; // 3 RootDataBlock root; };","title":"Version 3"},{"location":"formats/tanki/a3d/#root-block_1","text":"This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; };","title":"Root block"},{"location":"formats/tanki/a3d/#material-block_1","text":"struct A3DMaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; byte padding[]; // depends on materialBlockLength };","title":"Material block"},{"location":"formats/tanki/a3d/#mesh-block_1","text":"struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { string name; float bboxMaxX; float bboxMaxY; float bboxMaxZ; float bboxMinX; float bboxMinY; float bboxMinZ; float unknown; int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int indexCount; short indices[indexCount]; // array of 16 bit indices byte padding[]; // dependent on indexCount*2 } submeshes[submeshCount]; } mesh[meshCount]; byte padding[]; // depends on meshBlockLength };","title":"Mesh block"},{"location":"formats/tanki/a3d/#transform-block_1","text":"struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { string name; float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks byte padding[]; // depends on transformBlockLength };","title":"Transform block"},{"location":"formats/tanki/a3d/#object-block_1","text":"struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { int meshID; int transformID; int materialCount; int materialIDs[materialCount]; } objects[objectCount]; byte padding[]; // depends on objectBlockLength };","title":"Object block"},{"location":"formats/tanki/battlemap/","text":"BattleMap TODO","title":"BattleMap"},{"location":"formats/tanki/battlemap/#battlemap","text":"TODO","title":"BattleMap"},{"location":"formats/tanki/lightmapdata/","text":"LightmapData TODO","title":"LightmapData"},{"location":"formats/tanki/lightmapdata/#lightmapdata","text":"TODO","title":"LightmapData"},{"location":"formats/tanki/tara/","text":"Tara TODO","title":"Tara"},{"location":"formats/tanki/tara/#tara","text":"TODO","title":"Tara"}]}