{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"libalternativa C# based library to handle AlterativaPlatform and Tanki Online formats.","title":"Home"},{"location":"#libalternativa","text":"C# based library to handle AlterativaPlatform and Tanki Online formats.","title":"libalternativa"},{"location":"formats/alternativaprotocol/","text":"Alternativa Protocol TODO","title":"Alternativa Protocol"},{"location":"formats/alternativaprotocol/#alternativa-protocol","text":"TODO","title":"Alternativa Protocol"},{"location":"formats/alternativa3d/a3d/","text":"A3D (Alternativa3D) There are currently 2 major versions of the A3D format: A3D1 and A3D2 which are supported by the latest flash release of the Alternativa3D engine (8.32.0), this format is not related to the modern A3D format used in Tanki Online. A3D1 Oldest version of the format, uses the alternativa protocol serialisation format. Research materials Alternativa3D engine parser Format struct A3D1 { short version; // 1 short unused; // 0 OptionalMask optionalMask; A3D1Box boxes[]; // Optional A3D1Geometry geometry[]; // Optional A3D1Image images[]; // Optional A3D1Map maps[]; // Optional A3D1Material materials[]; // Optional A3D1Object objects[]; // Optional }; A3D1Box struct A3D1Box { float bounds[]; // Optional int id; // Optional }; A3D1Geometry struct A3D1Geometry { int id; // Optional A3D1IndexBuffer indexBuffer; // Optional A3D1VertexBuffer vertexBuffers[]; // Optional }; A3D1Image struct A3D1Image { int id; // Optional char url[]; // Optional }; A3D1Map struct A3D1Map { short channel; // Required int id; // Optional int imageID; // Optional float uOffset; // Optional float uScale; // Optional float vOffset; // Optional float vScale; // Optional }; A3D1Material struct A3D1Material { int diffuseMapID; // Optional int glossinessMapID; // Optional int id; // Optional int lightMapID; // Optional int normalMapID; // Optional int opacityMapID; // Optional int specularMapID; // Optional }; A3D1Object struct A3D1Object { int boundBoxID; // Optional int geometryID; // Optional int id; // Optional char name[]; // Optional int parentID; // Optional A3D1Surface surfaces[]; // Optional A3D1Transform transform; // Optional bool visible; // Optional }; A3D1Transform struct A3D1Transform { A3DMatrix matrix; // Optional }; A3D1IndexBuffer struct A3D1IndexBuffer { char byteBuffer[]; // Optional int indexCount; // Required }; A3D1VertexBuffer struct A3D1VertexBuffer { char attributes[]; // Optional char byteBuffer[]; // Optional short vertexCount; // Required }; attributes The attributes field specifies the format of each vertex inside the byteBuffer , there can be any amount of attributes in any order. It is read as 1 byte integers which each correspond to one of the vertex types: 0 - position 1 - normal 2 - tangent 3 - joint 4 - UV1 5 - UV2 A3D1Surface struct A3D1Surface { int indexBegin; // Required int materialID; // Optional int numTriangles; // Required }; A3D2 Newest version supported by the opensource flash Alternativa3D engine, also uses the alternativa protocol serialisation format (like A3D1). This version of the format adds zlib compression support, light objects, animation, skinning, sprites and decals as well as reducing amount of optional flags per model by properly using optional fields (only marking select fields as optional instead of most of them). There are 4 minor versions of this format: Version Notes 2.0 2.4 aka A3DExtra1, adds A3D2Layer 2.5 aka A3DExtra2, adds A3D2Camera, A3D2LOD 2.6 Package compression is mandatory Research materials Alternativa3D engine parser Official design document Format struct A3D2 { A3D2Package package; }; A3D2Package The A3D2 is wrapped in a compressable block called the package, it is placed at the very start of the file and begins with a length field, this is followed by a stream of bytes (size of the length field) which contains the A3D2 data (could be zlib compressed, this is encoded in the length field). Short package 0G000000 00000000 G Description 0 Package data is not compressed 1 Package data is compressed Length of the package is contained in the last 6 bits of the first byte + the next byte, resulting in a maximum length of 16,384 bytes. Long package 10000000 00000000 00000000 00000000 Length of the package is contained in the last 7 bits of the first byte + the next 3 bytes, resulting in a maximum length of 2147483648 bytes. Compression is assumed to be true. Data The uncompressed package data stores the actual file data: struct A3D2Package { OptionalMask optionalMask; A3D2AmbientLight ambientLights[]; // Optional A3D2AnimationClip animationClips[]; // Optional A3D2AnimationTrack animationTracks[]; // Optional A3D2Box boxes[]; // Optional A3D2CubeMap cubeMaps[]; // Optional A3D2Decal decals[]; // Optional A3D2DirectionalLight directionalLights[]; // Optional A3D2Image images[]; // Optional A3D2IndexBuffer indexBuffers[]; // Optional A3D2Joint joints[]; // Optional A3D2Map maps[]; // Optional A3D2Material materials[]; // Optional A3D2Mesh meshes[]; // Optional A3D2Object objects[]; // Optional A3D2OmniLight omniLights[]; // Optional A3D2SpotLight spotLights[]; // Optional A3D2Sprite sprites[]; // Optional A3D2Skin skins[]; // Optional A3D2VertexBuffer vertexBuffers[]; // Optional A3D2Layer layers[]; // Optional, 2.4 only A3D2Camera cameras[]; // Optional, 2.5 only A3D2LOD LODs[]; // Optional, 2.5 only }; A3D2AmbientLight A3D2AnimationClip A3D2AnimationTrack A3D2Box A3D2CubeMap A3D2Decal A3D2DirectionalLight A3D2Image A3D2IndexBuffer A3D2Joint A3D2Map A3D2Material A3D2Mesh A3D2Object A3D2OmniLight A3D2SpotLight A3D2Sprite A3D2Skin A3D2VertexBuffer A3D2Layer A3D2Camera A3D2LOD","title":"A3D"},{"location":"formats/alternativa3d/a3d/#a3d-alternativa3d","text":"There are currently 2 major versions of the A3D format: A3D1 and A3D2 which are supported by the latest flash release of the Alternativa3D engine (8.32.0), this format is not related to the modern A3D format used in Tanki Online.","title":"A3D (Alternativa3D)"},{"location":"formats/alternativa3d/a3d/#a3d1","text":"Oldest version of the format, uses the alternativa protocol serialisation format.","title":"A3D1"},{"location":"formats/alternativa3d/a3d/#research-materials","text":"Alternativa3D engine parser","title":"Research materials"},{"location":"formats/alternativa3d/a3d/#format","text":"struct A3D1 { short version; // 1 short unused; // 0 OptionalMask optionalMask; A3D1Box boxes[]; // Optional A3D1Geometry geometry[]; // Optional A3D1Image images[]; // Optional A3D1Map maps[]; // Optional A3D1Material materials[]; // Optional A3D1Object objects[]; // Optional };","title":"Format"},{"location":"formats/alternativa3d/a3d/#a3d1box","text":"struct A3D1Box { float bounds[]; // Optional int id; // Optional };","title":"A3D1Box"},{"location":"formats/alternativa3d/a3d/#a3d1geometry","text":"struct A3D1Geometry { int id; // Optional A3D1IndexBuffer indexBuffer; // Optional A3D1VertexBuffer vertexBuffers[]; // Optional };","title":"A3D1Geometry"},{"location":"formats/alternativa3d/a3d/#a3d1image","text":"struct A3D1Image { int id; // Optional char url[]; // Optional };","title":"A3D1Image"},{"location":"formats/alternativa3d/a3d/#a3d1map","text":"struct A3D1Map { short channel; // Required int id; // Optional int imageID; // Optional float uOffset; // Optional float uScale; // Optional float vOffset; // Optional float vScale; // Optional };","title":"A3D1Map"},{"location":"formats/alternativa3d/a3d/#a3d1material","text":"struct A3D1Material { int diffuseMapID; // Optional int glossinessMapID; // Optional int id; // Optional int lightMapID; // Optional int normalMapID; // Optional int opacityMapID; // Optional int specularMapID; // Optional };","title":"A3D1Material"},{"location":"formats/alternativa3d/a3d/#a3d1object","text":"struct A3D1Object { int boundBoxID; // Optional int geometryID; // Optional int id; // Optional char name[]; // Optional int parentID; // Optional A3D1Surface surfaces[]; // Optional A3D1Transform transform; // Optional bool visible; // Optional };","title":"A3D1Object"},{"location":"formats/alternativa3d/a3d/#a3d1transform","text":"struct A3D1Transform { A3DMatrix matrix; // Optional };","title":"A3D1Transform"},{"location":"formats/alternativa3d/a3d/#a3d1indexbuffer","text":"struct A3D1IndexBuffer { char byteBuffer[]; // Optional int indexCount; // Required };","title":"A3D1IndexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d1vertexbuffer","text":"struct A3D1VertexBuffer { char attributes[]; // Optional char byteBuffer[]; // Optional short vertexCount; // Required };","title":"A3D1VertexBuffer"},{"location":"formats/alternativa3d/a3d/#attributes","text":"The attributes field specifies the format of each vertex inside the byteBuffer , there can be any amount of attributes in any order. It is read as 1 byte integers which each correspond to one of the vertex types: 0 - position 1 - normal 2 - tangent 3 - joint 4 - UV1 5 - UV2","title":"attributes"},{"location":"formats/alternativa3d/a3d/#a3d1surface","text":"struct A3D1Surface { int indexBegin; // Required int materialID; // Optional int numTriangles; // Required };","title":"A3D1Surface"},{"location":"formats/alternativa3d/a3d/#a3d2","text":"Newest version supported by the opensource flash Alternativa3D engine, also uses the alternativa protocol serialisation format (like A3D1). This version of the format adds zlib compression support, light objects, animation, skinning, sprites and decals as well as reducing amount of optional flags per model by properly using optional fields (only marking select fields as optional instead of most of them). There are 4 minor versions of this format: Version Notes 2.0 2.4 aka A3DExtra1, adds A3D2Layer 2.5 aka A3DExtra2, adds A3D2Camera, A3D2LOD 2.6 Package compression is mandatory","title":"A3D2"},{"location":"formats/alternativa3d/a3d/#research-materials_1","text":"Alternativa3D engine parser Official design document","title":"Research materials"},{"location":"formats/alternativa3d/a3d/#format_1","text":"struct A3D2 { A3D2Package package; };","title":"Format"},{"location":"formats/alternativa3d/a3d/#a3d2package","text":"The A3D2 is wrapped in a compressable block called the package, it is placed at the very start of the file and begins with a length field, this is followed by a stream of bytes (size of the length field) which contains the A3D2 data (could be zlib compressed, this is encoded in the length field).","title":"A3D2Package"},{"location":"formats/alternativa3d/a3d/#short-package","text":"0G000000 00000000 G Description 0 Package data is not compressed 1 Package data is compressed Length of the package is contained in the last 6 bits of the first byte + the next byte, resulting in a maximum length of 16,384 bytes.","title":"Short package"},{"location":"formats/alternativa3d/a3d/#long-package","text":"10000000 00000000 00000000 00000000 Length of the package is contained in the last 7 bits of the first byte + the next 3 bytes, resulting in a maximum length of 2147483648 bytes. Compression is assumed to be true.","title":"Long package"},{"location":"formats/alternativa3d/a3d/#data","text":"The uncompressed package data stores the actual file data: struct A3D2Package { OptionalMask optionalMask; A3D2AmbientLight ambientLights[]; // Optional A3D2AnimationClip animationClips[]; // Optional A3D2AnimationTrack animationTracks[]; // Optional A3D2Box boxes[]; // Optional A3D2CubeMap cubeMaps[]; // Optional A3D2Decal decals[]; // Optional A3D2DirectionalLight directionalLights[]; // Optional A3D2Image images[]; // Optional A3D2IndexBuffer indexBuffers[]; // Optional A3D2Joint joints[]; // Optional A3D2Map maps[]; // Optional A3D2Material materials[]; // Optional A3D2Mesh meshes[]; // Optional A3D2Object objects[]; // Optional A3D2OmniLight omniLights[]; // Optional A3D2SpotLight spotLights[]; // Optional A3D2Sprite sprites[]; // Optional A3D2Skin skins[]; // Optional A3D2VertexBuffer vertexBuffers[]; // Optional A3D2Layer layers[]; // Optional, 2.4 only A3D2Camera cameras[]; // Optional, 2.5 only A3D2LOD LODs[]; // Optional, 2.5 only };","title":"Data"},{"location":"formats/alternativa3d/a3d/#a3d2ambientlight","text":"","title":"A3D2AmbientLight"},{"location":"formats/alternativa3d/a3d/#a3d2animationclip","text":"","title":"A3D2AnimationClip"},{"location":"formats/alternativa3d/a3d/#a3d2animationtrack","text":"","title":"A3D2AnimationTrack"},{"location":"formats/alternativa3d/a3d/#a3d2box","text":"","title":"A3D2Box"},{"location":"formats/alternativa3d/a3d/#a3d2cubemap","text":"","title":"A3D2CubeMap"},{"location":"formats/alternativa3d/a3d/#a3d2decal","text":"","title":"A3D2Decal"},{"location":"formats/alternativa3d/a3d/#a3d2directionallight","text":"","title":"A3D2DirectionalLight"},{"location":"formats/alternativa3d/a3d/#a3d2image","text":"","title":"A3D2Image"},{"location":"formats/alternativa3d/a3d/#a3d2indexbuffer","text":"","title":"A3D2IndexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d2joint","text":"","title":"A3D2Joint"},{"location":"formats/alternativa3d/a3d/#a3d2map","text":"","title":"A3D2Map"},{"location":"formats/alternativa3d/a3d/#a3d2material","text":"","title":"A3D2Material"},{"location":"formats/alternativa3d/a3d/#a3d2mesh","text":"","title":"A3D2Mesh"},{"location":"formats/alternativa3d/a3d/#a3d2object","text":"","title":"A3D2Object"},{"location":"formats/alternativa3d/a3d/#a3d2omnilight","text":"","title":"A3D2OmniLight"},{"location":"formats/alternativa3d/a3d/#a3d2spotlight","text":"","title":"A3D2SpotLight"},{"location":"formats/alternativa3d/a3d/#a3d2sprite","text":"","title":"A3D2Sprite"},{"location":"formats/alternativa3d/a3d/#a3d2skin","text":"","title":"A3D2Skin"},{"location":"formats/alternativa3d/a3d/#a3d2vertexbuffer","text":"","title":"A3D2VertexBuffer"},{"location":"formats/alternativa3d/a3d/#a3d2layer","text":"","title":"A3D2Layer"},{"location":"formats/alternativa3d/a3d/#a3d2camera","text":"","title":"A3D2Camera"},{"location":"formats/alternativa3d/a3d/#a3d2lod","text":"","title":"A3D2LOD"},{"location":"formats/tanki/a3d/","text":"A3D (Tanki Online) Custom 3D model format used by Tanki Online HTML5 for HD maps and all tank models (including legacy) to replace the old 3ds format (non HD maps still use 3ds). There are three versions of the A3D file format which are used for different types of objects in the game: version 1 files are no longer used, version 2 files are used for map geometry (props and terrain meshes etc...), version 3 files are used for tank models (turrets and hulls). The format is able to store: basic material data, mesh data (including coordinate, UV, normals and colour vertex buffers), submesh/surface data (with material indices), transform data and hierarchy data. Format Padding Padding is only used by version 3 models, it is calculated using: paddingSize = (((dataLength + 3) // 4) * 4) - dataLength Strings Version 2 uses null terminated strings, e.g. the strings have no length and characters are read from the stream until a null is reached ( \\0 ). Version 3 uses an int32 length field which comes before the characters with no null terminator, this is followed by padding bytes (padding calculated from string length). Data blocks The A3D file format is based around data blocks, data blocks are sections of the file which encode different data in the model such as meshes and materials. struct DataBlock { int dataBlockSignature; // Identifies which datablock this is int dataBlockLength; // This field is used to compute padding in version 3 files, other versions don't use it // Data block specifc data goes here }; Version 1 TODO Version 2 struct { char signature[4]; // \"A3D\\0\" int version; // 2 RootDataBlock root; }; Root block This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; }; Material block struct MaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; }; Mesh block struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int faceCount; short indices[faceCount*3]; // array of 16 bit indices int smoothingGroups[faceCount]; short materialID; } submeshes[submeshCount]; } mesh[meshCount]; }; Transform block struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks }; Object block struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { string name; int meshID; int transformID; } objects[objectCount]; }; Version 3 struct { char signature[4]; // \"A3D\\0\" int version; // 3 RootDataBlock root; }; Root block This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; }; Material block struct A3DMaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; byte padding[]; // depends on materialBlockLength }; Mesh block struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { string name; float bboxMaxX; float bboxMaxY; float bboxMaxZ; float bboxMinX; float bboxMinY; float bboxMinZ; float unknown; int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int indexCount; short indices[indexCount]; // array of 16 bit indices byte padding[]; // dependent on indexCount*2 } submeshes[submeshCount]; } mesh[meshCount]; byte padding[]; // depends on meshBlockLength }; Transform block struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { string name; float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks byte padding[]; // depends on transformBlockLength }; Object block struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { int meshID; int transformID; int materialCount; int materialIDs[materialCount]; } objects[objectCount]; byte padding[]; // depends on objectBlockLength };","title":"A3D"},{"location":"formats/tanki/a3d/#a3d-tanki-online","text":"Custom 3D model format used by Tanki Online HTML5 for HD maps and all tank models (including legacy) to replace the old 3ds format (non HD maps still use 3ds). There are three versions of the A3D file format which are used for different types of objects in the game: version 1 files are no longer used, version 2 files are used for map geometry (props and terrain meshes etc...), version 3 files are used for tank models (turrets and hulls). The format is able to store: basic material data, mesh data (including coordinate, UV, normals and colour vertex buffers), submesh/surface data (with material indices), transform data and hierarchy data.","title":"A3D (Tanki Online)"},{"location":"formats/tanki/a3d/#format","text":"","title":"Format"},{"location":"formats/tanki/a3d/#padding","text":"Padding is only used by version 3 models, it is calculated using: paddingSize = (((dataLength + 3) // 4) * 4) - dataLength","title":"Padding"},{"location":"formats/tanki/a3d/#strings","text":"Version 2 uses null terminated strings, e.g. the strings have no length and characters are read from the stream until a null is reached ( \\0 ). Version 3 uses an int32 length field which comes before the characters with no null terminator, this is followed by padding bytes (padding calculated from string length).","title":"Strings"},{"location":"formats/tanki/a3d/#data-blocks","text":"The A3D file format is based around data blocks, data blocks are sections of the file which encode different data in the model such as meshes and materials. struct DataBlock { int dataBlockSignature; // Identifies which datablock this is int dataBlockLength; // This field is used to compute padding in version 3 files, other versions don't use it // Data block specifc data goes here };","title":"Data blocks"},{"location":"formats/tanki/a3d/#version-1","text":"TODO","title":"Version 1"},{"location":"formats/tanki/a3d/#version-2","text":"struct { char signature[4]; // \"A3D\\0\" int version; // 2 RootDataBlock root; };","title":"Version 2"},{"location":"formats/tanki/a3d/#root-block","text":"This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; };","title":"Root block"},{"location":"formats/tanki/a3d/#material-block","text":"struct MaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; };","title":"Material block"},{"location":"formats/tanki/a3d/#mesh-block","text":"struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int faceCount; short indices[faceCount*3]; // array of 16 bit indices int smoothingGroups[faceCount]; short materialID; } submeshes[submeshCount]; } mesh[meshCount]; };","title":"Mesh block"},{"location":"formats/tanki/a3d/#transform-block","text":"struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks };","title":"Transform block"},{"location":"formats/tanki/a3d/#object-block","text":"struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { string name; int meshID; int transformID; } objects[objectCount]; };","title":"Object block"},{"location":"formats/tanki/a3d/#version-3","text":"struct { char signature[4]; // \"A3D\\0\" int version; // 3 RootDataBlock root; };","title":"Version 3"},{"location":"formats/tanki/a3d/#root-block_1","text":"This contains all model data blocks. struct RootDataBlock { int rootBlockSignature; int rootBlockLength; MaterialBlock materialBlock; MeshBlock meshBlock; TransformBlock transformBlock; ObjectBlock objectBlock; };","title":"Root block"},{"location":"formats/tanki/a3d/#material-block_1","text":"struct A3DMaterialBlock { int materialBlockSignature; int materialBlockLength; int materialCount; struct A3DMaterial { string name; float colorR; float colorG; float colorB; string diffuseMap; } materials[materialCount]; byte padding[]; // depends on materialBlockLength };","title":"Material block"},{"location":"formats/tanki/a3d/#mesh-block_1","text":"struct MeshBlock { int meshBlockSignature; int meshBlockLength; int meshCount; struct Mesh { string name; float bboxMaxX; float bboxMaxY; float bboxMaxZ; float bboxMinX; float bboxMinY; float bboxMinZ; float unknown; int vertexCount; int vertexBufferCount; struct VertexBuffer { int bufferType; float vertices[]; // vertex size * vertex count } vertexBuffers[vertexBufferCount]; int submeshCount; struct Submesh { int indexCount; short indices[indexCount]; // array of 16 bit indices byte padding[]; // dependent on indexCount*2 } submeshes[submeshCount]; } mesh[meshCount]; byte padding[]; // depends on meshBlockLength };","title":"Mesh block"},{"location":"formats/tanki/a3d/#transform-block_1","text":"struct TransformBlock { int transformBlockSignature; int transformBlockLength; int transformCount; struct Transform { string name; float positionX; float positionY; float positionZ; float rotationX; float rotationY; float rotationZ; float rotationW; float scaleX; float scaleY; float scaleZ; } transforms[transformCount]; int transformIDs[transformCount]; // Each ID corresponds to a transform component at the same index, this ID is referenced by external data blocks byte padding[]; // depends on transformBlockLength };","title":"Transform block"},{"location":"formats/tanki/a3d/#object-block_1","text":"struct ObjectBlock { int objectBlockSignature; int objectBlockLength; int objectCount; struct Object { int meshID; int transformID; int materialCount; int materialIDs[materialCount]; } objects[objectCount]; byte padding[]; // depends on objectBlockLength };","title":"Object block"},{"location":"formats/tanki/battlemap/","text":"BattleMap (map.bin) Binary based map file format that replaced JSON and XML based formats, it is exported out of the unity editor and stored as map.bin . Format This file is wrapped and serialised using the Alternativa Protocol, it has no signature or header and is simply a protocol packet with optional mask. struct BattleMap { OptionalMask optionalMask; // See Alternativa Protocol documentation Atlas atlases[]; // Optional Batch batches[]; // Optional CollisionGeometry collisionGeometry; // Required CollisionGeometry collisionGeometryOutsideGamingZone; // Required Material materials[]; // Required SpawnPoint spawnPoints[]; // Optional Prop staticGeometry[]; // Required }; Atlas Defines an atlas file, atlas texture files store all the textures required by the map, they are stored next to the map.bin file. struct Atlas { uint32_t height; // Required string name; // Required uint32_t padding; // Required AtlasRect rects[]; // Required uint32_t width; // Required }; AtlasRect Defines an individual texture in the atlas. struct AtlasRect { uint32_t height; // Required string libraryName; // Required string name; // Required uint32_t width; // Required uint32_t x; // Required uint32_t y; // Required }; Batch Defines a render batch, a group of geometry which shares the same material and can be rendered together. struct Batch { uint32_t materialID; // Required string name; // Required vec3 position; // Required string propIDs; // Required }; CollisionGeometry Stores physics information, collision meshes for the map. struct CollisionGeometry { CollisionBox collisionBoxes[]; // Required CollisionPlane collisionPlanes[]; // Required CollisionTriangle collisionTriangles[]; // Required }; CollisionBox Primitive box physics collider. struct CollisionBox { vec3 Position; // Required vec3 Rotation; // Required vec3 Scale; // Required }; CollisionPlane Primitive plane physics collider. struct CollisionPlane { double length; // Required vec3 position; // Required vec3 rotation; // Required double width; // Required }; CollisionTriangle Primitive triangle physics collider. struct CollisionTriangle { double length; // Required vec3 position; // Required vec3 rotation; // Required float vertices[3]; // Required }; Material Defines a material used within the map. struct Material { uint32_t ID; // Required string name; // Required ScalarParameter scalarParameters[]; // Optional string shader; // Required TextureParameter textureParameters[]; // Required Vector2Parameter vector2Parameters[]; // Optional Vector3Parameter vector3Parameters[]; // Optional Vector4Parameter vector4Parameters[]; // Optional }; ScalarParameter Defines a material parameter with one component. struct ScalarParameter { string name; // Required float value; // Required }; Vector2Parameter Defines a material parameter with two components. struct Vector2Parameter { string name; // Required vec2 value; // Required }; Vector3Parameter Defines a material parameter with three components. struct Vector3Parameter { string name; // Required vec3 value; // Required }; Vector4Parameter Defines a material parameter with four components. struct Vector4Parameter { string name; // Required vec4 value; // Required }; SpawnPoint A point at which tanks can spawn, specific to different gamemodes. struct SpawnPoint { vec3 position; // Required vec3 rotation; // Required uint32_t type; // Required }; type Specifies which gamemode and team the spawn is for. enum SpawnType { TUTORIAL_PLAYER = 0, TUTORIAL_BOT = 1, TEAM_A = 2, TEAM_B = 3, DM = 4, DOM = 5, DOM_TEAM_A = 6, DOM_TEAM_B = 7, RUGBY_TEAM_A = 8, RUGBY_TEAM_B = 9, SURVIVAL_TEAM_A = 10, SURVIVAL_TEAM_B = 11, SURVIVAL_NEUTRAL = 12, ASSAULT_ATTACKING = 13, ASSAULT_DEFENDING = 14, SGE_TEAM_A = 15, SGE_TEAM_B = 16, TJR_TEAM_A = 17, TJR_TEAM_B = 18, }; Prop Defines a visual object within the map. struct Prop { string groupName; // Optional uint32_t ID; // Required string libraryName; // Required uint32_t materialID; // Required string name; // Required vec3 position; // Required vec3 rotation; // Optional vec3 scale; // Optional };","title":"BattleMap"},{"location":"formats/tanki/battlemap/#battlemap-mapbin","text":"Binary based map file format that replaced JSON and XML based formats, it is exported out of the unity editor and stored as map.bin .","title":"BattleMap (map.bin)"},{"location":"formats/tanki/battlemap/#format","text":"This file is wrapped and serialised using the Alternativa Protocol, it has no signature or header and is simply a protocol packet with optional mask. struct BattleMap { OptionalMask optionalMask; // See Alternativa Protocol documentation Atlas atlases[]; // Optional Batch batches[]; // Optional CollisionGeometry collisionGeometry; // Required CollisionGeometry collisionGeometryOutsideGamingZone; // Required Material materials[]; // Required SpawnPoint spawnPoints[]; // Optional Prop staticGeometry[]; // Required };","title":"Format"},{"location":"formats/tanki/battlemap/#atlas","text":"Defines an atlas file, atlas texture files store all the textures required by the map, they are stored next to the map.bin file. struct Atlas { uint32_t height; // Required string name; // Required uint32_t padding; // Required AtlasRect rects[]; // Required uint32_t width; // Required };","title":"Atlas"},{"location":"formats/tanki/battlemap/#atlasrect","text":"Defines an individual texture in the atlas. struct AtlasRect { uint32_t height; // Required string libraryName; // Required string name; // Required uint32_t width; // Required uint32_t x; // Required uint32_t y; // Required };","title":"AtlasRect"},{"location":"formats/tanki/battlemap/#batch","text":"Defines a render batch, a group of geometry which shares the same material and can be rendered together. struct Batch { uint32_t materialID; // Required string name; // Required vec3 position; // Required string propIDs; // Required };","title":"Batch"},{"location":"formats/tanki/battlemap/#collisiongeometry","text":"Stores physics information, collision meshes for the map. struct CollisionGeometry { CollisionBox collisionBoxes[]; // Required CollisionPlane collisionPlanes[]; // Required CollisionTriangle collisionTriangles[]; // Required };","title":"CollisionGeometry"},{"location":"formats/tanki/battlemap/#collisionbox","text":"Primitive box physics collider. struct CollisionBox { vec3 Position; // Required vec3 Rotation; // Required vec3 Scale; // Required };","title":"CollisionBox"},{"location":"formats/tanki/battlemap/#collisionplane","text":"Primitive plane physics collider. struct CollisionPlane { double length; // Required vec3 position; // Required vec3 rotation; // Required double width; // Required };","title":"CollisionPlane"},{"location":"formats/tanki/battlemap/#collisiontriangle","text":"Primitive triangle physics collider. struct CollisionTriangle { double length; // Required vec3 position; // Required vec3 rotation; // Required float vertices[3]; // Required };","title":"CollisionTriangle"},{"location":"formats/tanki/battlemap/#material","text":"Defines a material used within the map. struct Material { uint32_t ID; // Required string name; // Required ScalarParameter scalarParameters[]; // Optional string shader; // Required TextureParameter textureParameters[]; // Required Vector2Parameter vector2Parameters[]; // Optional Vector3Parameter vector3Parameters[]; // Optional Vector4Parameter vector4Parameters[]; // Optional };","title":"Material"},{"location":"formats/tanki/battlemap/#scalarparameter","text":"Defines a material parameter with one component. struct ScalarParameter { string name; // Required float value; // Required };","title":"ScalarParameter"},{"location":"formats/tanki/battlemap/#vector2parameter","text":"Defines a material parameter with two components. struct Vector2Parameter { string name; // Required vec2 value; // Required };","title":"Vector2Parameter"},{"location":"formats/tanki/battlemap/#vector3parameter","text":"Defines a material parameter with three components. struct Vector3Parameter { string name; // Required vec3 value; // Required };","title":"Vector3Parameter"},{"location":"formats/tanki/battlemap/#vector4parameter","text":"Defines a material parameter with four components. struct Vector4Parameter { string name; // Required vec4 value; // Required };","title":"Vector4Parameter"},{"location":"formats/tanki/battlemap/#spawnpoint","text":"A point at which tanks can spawn, specific to different gamemodes. struct SpawnPoint { vec3 position; // Required vec3 rotation; // Required uint32_t type; // Required };","title":"SpawnPoint"},{"location":"formats/tanki/battlemap/#type","text":"Specifies which gamemode and team the spawn is for. enum SpawnType { TUTORIAL_PLAYER = 0, TUTORIAL_BOT = 1, TEAM_A = 2, TEAM_B = 3, DM = 4, DOM = 5, DOM_TEAM_A = 6, DOM_TEAM_B = 7, RUGBY_TEAM_A = 8, RUGBY_TEAM_B = 9, SURVIVAL_TEAM_A = 10, SURVIVAL_TEAM_B = 11, SURVIVAL_NEUTRAL = 12, ASSAULT_ATTACKING = 13, ASSAULT_DEFENDING = 14, SGE_TEAM_A = 15, SGE_TEAM_B = 16, TJR_TEAM_A = 17, TJR_TEAM_B = 18, };","title":"type"},{"location":"formats/tanki/battlemap/#prop","text":"Defines a visual object within the map. struct Prop { string groupName; // Optional uint32_t ID; // Required string libraryName; // Required uint32_t materialID; // Required string name; // Required vec3 position; // Required vec3 rotation; // Optional vec3 scale; // Optional };","title":"Prop"},{"location":"formats/tanki/jsonmap/","text":"JSON map TODO","title":"JSON map"},{"location":"formats/tanki/jsonmap/#json-map","text":"TODO","title":"JSON map"},{"location":"formats/tanki/lightmapdata/","text":"LightmapData TODO","title":"LightmapData"},{"location":"formats/tanki/lightmapdata/#lightmapdata","text":"TODO","title":"LightmapData"},{"location":"formats/tanki/tara/","text":"Tara Tanki Online resource archive, simple format that packs multiple files (without compression) into one archive. These files were utilised to store the game's prop libraries. Format The file utilises big endian encoding throughout. File table The file has no proper header or signature, it just starts with a table of files contained withing the archive. struct FileTable { int fileCount; struct FileInfo { uint16_t filenameLength; char filename[filenameLength]; uint32_t fileLength; } fileInfo[fileCount]; } File blob The file table is immediately followed by all the packed files stacked back to back with each other: <file1 data><file2 data><file3 data>","title":"Tara"},{"location":"formats/tanki/tara/#tara","text":"Tanki Online resource archive, simple format that packs multiple files (without compression) into one archive. These files were utilised to store the game's prop libraries.","title":"Tara"},{"location":"formats/tanki/tara/#format","text":"The file utilises big endian encoding throughout.","title":"Format"},{"location":"formats/tanki/tara/#file-table","text":"The file has no proper header or signature, it just starts with a table of files contained withing the archive. struct FileTable { int fileCount; struct FileInfo { uint16_t filenameLength; char filename[filenameLength]; uint32_t fileLength; } fileInfo[fileCount]; }","title":"File table"},{"location":"formats/tanki/tara/#file-blob","text":"The file table is immediately followed by all the packed files stacked back to back with each other: <file1 data><file2 data><file3 data>","title":"File blob"},{"location":"formats/tanki/xmlmap/","text":"XML map TODO","title":"XML map"},{"location":"formats/tanki/xmlmap/#xml-map","text":"TODO","title":"XML map"}]}